# CS-250
1. How do I interpret user needs and implement them into a program? How does creating “user stories” help with this?
Interpreting user needs involves understanding what users are trying to accomplish and why, not just what they explicitly ask for.

Understand the Problem: Use methods like interviews, surveys, observations, and analyzing existing systems to grasp the users' workflows, pain points, and goals. Ask "why" frequently (the 5 Whys technique) to get to the root need.

Define Requirements: Translate the gathered information into specific, measurable, achievable, relevant, and time-bound (SMART) requirements. These fall into functional requirements (what the system must do) and non-functional requirements (qualities like performance, security, and usability).

Implement and Validate: Design and code the program based on these requirements. Continuously test and validate the implemented features with real users to ensure they truly solve the original problem and meet the needs.

User Stories are short, simple descriptions of a feature told from the perspective of the person who desires the new capability, usually a user or customer.

They follow a standard format: As a [type of user], I want [some goal] so that [some reason].

User stories help because they:

Focus on Value: They emphasize the benefit ("so that") to the user, ensuring the team builds features that deliver actual value.

Facilitate Communication: They use non-technical language that is easily understood by developers, testers, and stakeholders.

Aid Prioritization: They make features easier to discuss, estimate, and prioritize based on business and user value.

Stay User-Centric: They keep the development team focused on the user's perspective and needs throughout the process.

2. How do I approach developing programs? What Agile processes do I hope to incorporate into my future development work?
A structured and iterative approach is key to effective program development.

Program Development Approach
Planning and Discovery: Define the scope, gather initial requirements, and identify key constraints (time, budget, resources).

Design and Prototyping: Create high-level architecture, detailed design specifications, and potentially low-fidelity or high-fidelity prototypes to visualize the solution.

Implementation (Coding): Write the code, focusing on clean, maintainable, and well-tested units.

Testing and Quality Assurance (QA): Verify the system against requirements, performing unit, integration, system, and user acceptance testing (UAT).

Deployment: Release the software to the target environment (e.g., production).

Review and Maintenance: Monitor the deployed application, gather feedback, and continuously update or fix issues. This often leads back to step 1 for the next iteration.

Agile is a set of principles for iterative and incremental development, where requirements and solutions evolve through the collaborative effort of self-organizing cross-functional teams.

Key Agile practices I'd hope to incorporate:

Scrums or Sprints: Working in short, time-boxed iterations (usually 1-4 weeks) called sprints or iterations, each resulting in a potentially shippable product increment.

Daily Stand-ups (Daily Scrums): Short daily meetings (15 mins max) where team members quickly share what they did yesterday, what they'll do today, and any roadblocks they face.

Retrospectives: Meetings held after each sprint to discuss what went well, what could be improved, and how to make the next sprint better. This drives continuous improvement.

Continuous Integration/Continuous Delivery (CI/CD): Implementing automated tools to frequently merge code, build the application, and test and deploy updates reliably and quickly.

Customer Collaboration: Actively involving users and stakeholders throughout the development cycle, rather than only at the beginning and end.

3. What does it mean to be a good team member in software development?

Being a good team member in software development goes beyond just writing good code; it's about collaboration, communication, and shared ownership.

Proactive Communication: Clearly and promptly communicate progress, roadblocks, and any changes in understanding of a task. Don't let issues fester; ask for help early.

Shared Code Ownership: Take responsibility for the quality of the entire product, not just your assigned features. This means participating in code reviews constructively and ensuring your code is well-tested and documented.

Reliability and Accountability: Meet commitments (e.g., finishing a task within the agreed-upon sprint time) and be honest about your capacity and limitations.

Flexibility and Adaptability: Be willing to take on different tasks, learn new technologies quickly, and adapt to changing requirements or priorities without excessive friction.

Positive and Constructive Attitude: Offer constructive feedback during code reviews and retrospectives, focusing on the work and the process, not the people. Be supportive of teammates' efforts and successes.
